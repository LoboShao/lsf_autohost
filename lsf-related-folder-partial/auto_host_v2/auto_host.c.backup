#include <stdlib.h>
#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <curl/curl.h>
#include <unistd.h>
#include "lssched.h"

static const int HANDLER_ID = 118;

#ifndef MAXLINELEN
#define MAXLINELEN 512
#endif

#ifndef FREEUP
#define FREEUP(p) { if ( p ) { free(p); (p) = NULL; } }
#endif

/* ML Server configuration */
#define ML_SERVER_URL "http://localhost:5000/select_host"
#define JSON_BUFFER_SIZE 65536

/* Plugin data structure for AUTO_HOST requests */
typedef struct {
    int useAutoHost;  /* flag indicating this job uses auto host selection */
    char *input_vector; /* stores the vector string from AUTO_HOST[...] */
} autohost_data;

/* Memory buffer for CURL responses */
struct MemoryStruct {
    char *memory;
    size_t size;
};



/* Function declarations */
static autohost_data *create_autohost_data(void);
static void destroy_autohost_data(void *p);
static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp);
static char *callMLServer(const char *jsonData);
int parseMLResponse(const char *jsonResponse, double *scores, int count);


/* Callback functions */
static int autohost_new(void *resreq);
static int autohost_sort(autohost_data *data, void *candGroupList, void *reasonTb);
static void autohost_free(autohost_data *data);
static int autohost_checkAlloc(autohost_data *data, void *job, void *alloc, void *allocLimitList);
static int autohost_notifyAlloc(autohost_data *data, void *job, void *alloc, void *allocLimitList, int flag);

/*-------------------------------------------------------------------------
 * Plugin framework functions
 *-------------------------------------------------------------------------*/
int sched_version(void *param)
{
    return (0);
}

int sched_init(void *param)
{
    static char fname[] = "autohost_sched_init";
    RsrcReqHandlerType *handler = NULL;
    
    ls_syslog(LOG_DEBUG, "%s: entering...", fname);
    
    handler = (RsrcReqHandlerType *)calloc(1, sizeof(RsrcReqHandlerType));
    if (handler == NULL) {
        ls_syslog(LOG_ERR, "%s: calloc() failed", fname);
        return (-1);
    }

    handler->newFn = (RsrcReqHandler_NewFn) autohost_new;
    handler->freeFn = (RsrcReqHandler_FreeFn) autohost_free;
    handler->matchFn = (RsrcReqHandler_MatchFn) NULL;

    // extsched_cand_getnextgroup()
    // extsched_host_resources()
    handler->sortFn = (RsrcReqHandler_SortFn) autohost_sort;
    handler->notifyAllocFn = (RsrcReqHandler_NotifyAllocFn) autohost_notifyAlloc;
    handler->checkAllocFn = (RsrcReqHandler_CheckAllocFn) autohost_checkAlloc;

    extsched_resreq_registerhandler(HANDLER_ID, handler);
    ls_syslog(LOG_INFO, "%s: Handler registered with ID %d", fname, HANDLER_ID);

    FREEUP(handler);
    
    /* Initialize CURL globally */
    curl_global_init(CURL_GLOBAL_ALL);
    
    srand(time(NULL));  /* Initialize random seed */
    return (0);
}


// >>
int sched_pre_proc(void *param) { return (0); }


int sched_match_limit(void *param) { return (0); }
int sched_order_alloc(void *param) { return (0); }
int sched_post_proc(void *param) { return (0); }

int sched_finalize(void *param) 
{ 
    /* Cleanup CURL */
    curl_global_cleanup();
    return (0); 
}

/*-------------------------------------------------------------------------
 * Callback handler functions
 *-------------------------------------------------------------------------*/
static int autohost_new(void *resreq)
{
    static char fname[] = "autohost_new";
    char **extsched;
    int num = 0;

    ls_syslog(LOG_DEBUG, "%s: entering...", fname);

    if (resreq == NULL) {
        return (0);
    }

    extsched = extsched_resreq_getextresreq(resreq, &num);


    if (extsched == NULL || num <= 0) {
        return (0);
    }

    if (num > 1 && extsched[0]) {
        char *pAUTO_HOST = strstr(extsched[0], "AUTO_HOST[");
        
        if (pAUTO_HOST && strchr(pAUTO_HOST, ']')) {
            autohost_data *data;
            char key[MAXLINELEN];
            static int reqId = 0;

            data = create_autohost_data();
            if (data == NULL) {
                ls_syslog(LOG_ERR, "%s: create_autohost_data() failed", fname);
                return (-1);
            }

            data->useAutoHost = 1;
            // Extract and store the vector string from AUTO_HOST[...]
            char *start = strchr(pAUTO_HOST, '[');
            char *end = strchr(pAUTO_HOST, ']');
            if (start && end && end > start + 1) {
                size_t vlen = end - start - 1;
                data->input_vector = (char *)calloc(vlen + 1, 1);
                strncpy(data->input_vector, start + 1, vlen);
                data->input_vector[vlen] = '\0';
            } else {
                data->input_vector = NULL;
            }
            snprintf(key, sizeof(key), "#AUTO_HOST[]#%d#", reqId++);
            
            ls_syslog(LOG_DEBUG, "%s: auto host selection enabled, key=<%s>", fname, key);
            extsched_resreq_setobject(resreq, HANDLER_ID, key, data);
        }
    }

    return (0);
}





static int autohost_sort(autohost_data *data, void *candGroupList, void *reasonTb)
{

    
    static char fname[] = "autohost_sort";
    struct candHostGroup *candGroupEntry = NULL;

    ls_syslog(LOG_DEBUG, "%s: entering...", fname);

    if (data == NULL || !data->useAutoHost) {
        ls_syslog(LOG_DEBUG, "%s: skipping - not an autohost job", fname);
        return 0;  // Not our job
    }

    if (candGroupList == NULL) {
        ls_syslog(LOG_DEBUG, "%s: candidate group list is NULL", fname);
        return -1;
    }

    // Use the stored input_vector string to call ML server
    // In that way, we don't need to modify the plugin because the input_vector is already set in the autohost_data structure
    if (!data->input_vector) {
        ls_syslog(LOG_ERR, "%s: input_vector is NULL", fname);
        return -2;
    }

    // Build JSON for ML server
    char jsonBuffer[JSON_BUFFER_SIZE];
    snprintf(jsonBuffer, sizeof(jsonBuffer), "{\"input_vector\": [%s]}", data->input_vector);
    char *jsonResponse = callMLServer(jsonBuffer);
    candGroupEntry = lsb_cand_getnextgroup(candGroupList);

    if (!jsonResponse) {
        ls_syslog(LOG_DEBUG, "%s: ML server returned NULL response", fname);
        return -2;  // ML server failure
    }

    if (candGroupEntry == NULL) {
        ls_syslog(LOG_DEBUG, "%s: candidate group is NULL", fname);
        return -3;
    }

    int numCandidates = candGroupEntry->numOfMembers;
    double *scores = malloc(sizeof(double) * numCandidates);
    if (!scores) {
        ls_syslog(LOG_DEBUG, "%s: memory allocation failed for scores", fname);
        return -4;
    }

    int parsed = parseMLResponse(jsonResponse, scores, numCandidates);
    if (parsed != numCandidates) {
        ls_syslog(LOG_DEBUG, "%s: parseMLResponse error: parsed %d, expected %d", fname, parsed, numCandidates);
        free(scores);
        FREEUP(jsonResponse);
        return -5;
    }

    ls_syslog(LOG_DEBUG, "%s: successfully parsed %d scores", fname, parsed);

    for (int i = 0; i < numCandidates - 1; i++) {
        for (int j = 0; j < numCandidates - 1 - i; j++) {
            if (scores[j] < scores[j + 1]) {
                struct candHost temp = candGroupEntry->candHost[j];
                candGroupEntry->candHost[j] = candGroupEntry->candHost[j + 1];
                candGroupEntry->candHost[j + 1] = temp;
                
                double tempScore = scores[j];
                scores[j] = scores[j + 1];
                scores[j + 1] = tempScore;
            }
        }
    }
    free(scores);
    FREEUP(jsonResponse); // prevent memory leak
    return 0;
}


static void autohost_free(autohost_data *data)
{
    static char fname[] = "autohost_free";
    ls_syslog(LOG_DEBUG, "%s: entering...", fname);
    destroy_autohost_data((void *)data);
}

static int autohost_checkAlloc(autohost_data *data, void *job, void *alloc, void *allocLimitList)
{
    static char fname[] = "autohost_checkAlloc";
    
    if (data == NULL || !data->useAutoHost) {
        return (0);
    }

    ls_syslog(LOG_DEBUG, "%s: checking allocation for auto host job", fname);
    /* No additional checks needed for auto host selection */
    return (0);
}

static int autohost_notifyAlloc(autohost_data *data, void *job, void *alloc, void *allocLimitList, int flag)
{
    static char fname[] = "autohost_notifyAlloc";
    
    if (data == NULL || !data->useAutoHost) {
        return (0);
    }
    ls_syslog(LOG_DEBUG, "%s: checking allocation for auto host job", fname);
    return (0);
}
/*-------------------------------------------------------------------------
 * Helper functions
 *-------------------------------------------------------------------------*/
static autohost_data *create_autohost_data(void)
{
   autohost_data *data = (autohost_data *)calloc(1, sizeof(autohost_data));
   if (data == NULL) {
       return NULL;
   }
   data->useAutoHost = 0;
   data->input_vector = NULL;
   return data;
}

static void destroy_autohost_data(void *p)
{
   autohost_data *data = (autohost_data *)p;
   if (data) {
       if (data->input_vector) {
           FREEUP(data->input_vector);
       }
       FREEUP(data);
   }
}

/*-------------------------------------------------------------------------
 * CURL callback for receiving data
 *-------------------------------------------------------------------------*/
static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
    size_t realsize = size * nmemb;
    struct MemoryStruct *mem = (struct MemoryStruct *)userp;

    char *ptr = realloc(mem->memory, mem->size + realsize + 1);
    if(ptr == NULL) {
        /* out of memory! */
        ls_syslog(LOG_ERR, "WriteMemoryCallback: not enough memory (realloc returned NULL)");
        return 0;
    }

    mem->memory = ptr;
    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;

    return realsize;
}

/*-------------------------------------------------------------------------
 * ML Host Selection Functions
 *-------------------------------------------------------------------------*/
static char *callMLServer(const char *jsonData)
{
    static char fname[] = "callMLServer";
    CURL *curl;
    CURLcode res;
    struct MemoryStruct chunk;
    struct curl_slist *headers = NULL;

    chunk.memory = malloc(1);  // will be grown as needed by realloc
    chunk.size = 0;

    curl_global_init(CURL_GLOBAL_ALL);
    curl = curl_easy_init();

    if (!curl) {
        fprintf(stderr, "%s: Failed to initialize CURL\n", fname);
        return NULL;
    }

    headers = curl_slist_append(headers, "Content-Type: application/json");

    curl_easy_setopt(curl, CURLOPT_URL, ML_SERVER_URL);
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, jsonData);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L);

    res = curl_easy_perform(curl);

    if (res != CURLE_OK) {
        fprintf(stderr, "%s: curl_easy_perform() failed: %s\n", fname, curl_easy_strerror(res));
        FREEUP(chunk.memory);
        chunk.memory = NULL;
    } else {
        // Print full response
        printf("Response from server: %s\n", chunk.memory);
    }

    curl_easy_cleanup(curl);
    curl_slist_free_all(headers);
    curl_global_cleanup();

    return chunk.memory;  // WARNING: must not FREEUP here if returning it
}

int parseMLResponse(const char *jsonResponse, double *scores, int count)
{
    char *scores_start = strstr(jsonResponse, "\"scores\":[");
    if (!scores_start) return -1;
    
    scores_start += 10; // Skip "scores":["
    
    for (int i = 0; i < count; i++) {
        scores[i] = strtod(scores_start, &scores_start);
        if (*scores_start == ',') scores_start++; // Skip comma
    }
    
    return count;
}
